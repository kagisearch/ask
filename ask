#!/usr/bin/env bash

# ask - Simple Claude Code CLI wrapper
# Usage: ask [OPTIONS] [PROMPT]

set -euo pipefail

# Check for Claude CLI
if ! command -v claude &> /dev/null; then
    echo "Error: claude command not found. Install Claude Code CLI first." >&2
    echo "Visit: https://claude.com/claude-code" >&2
    exit 1
fi

# Model shortcuts function
get_model() {
    case "$1" in
        s) echo "sonnet" ;;
        o) echo "opus" ;;
        h) echo "haiku" ;;
    esac
}

# System information caching
CACHE_DIR="${XDG_CACHE_HOME:-$HOME/.cache}/ask"
CACHE_FILE="$CACHE_DIR/sysinfo"
CACHE_MAX_AGE=86400  # 24 hours in seconds

# Default values
MODEL="sonnet"
SYSTEM_PROMPT=""
PROMPT=""
NO_SYSTEM=false
DEBUG=false
WITH_CONTEXT=false
SHOW_STATS=false
ALLOW_EDITS=true  # Enable file edits by default
PERMISSION_MODE=""
ALLOWED_TOOLS=""

# Default system prompt (direct answers)
DEFAULT_PROMPT="You are a direct answer engine. Output ONLY the requested information.

For commands: Output executable syntax only. No explanations, no comments.
For questions: Output the answer only. No context, no elaboration.

Rules:
- If asked for a command, provide ONLY the command
- If asked a question, provide ONLY the answer
- Never include markdown formatting or code blocks
- Never add explanatory text before or after
- Assume output will be piped or executed directly
- For multi-step commands, use && or ; to chain them
- Make commands robust and handle edge cases silently"

# Function to show help
show_help() {
    cat << EOF
ask - Query Claude AI via Claude Code CLI

Usage: ask [OPTIONS] [PROMPT]

Options:
  -s               Use Claude Sonnet (default)
  -o               Use Claude Opus
  -h               Use Claude Haiku
  -m MODEL         Use custom Claude model
  -r               Disable system prompt (raw model behavior)
  --system TEXT    Set custom system prompt for the conversation
  --context        Pipe stdin as context, combine with prompt argument
  --no-edits       Disable file editing (enabled by default)
  --permission-mode MODE    Set permission mode (e.g., acceptEdits)
  --allowed-tools TOOLS     Comma-separated list of allowed tools
  --stats          Show statistics (time, tool calls, tokens, cost)
  --debug          Show system context, prompts, and command (stderr)
  --help           Show this help message

Note: File editing is enabled by default in the current working directory.

Examples:
  # Basic usage
  ask "Write a hello world in Python"
  ask -o "Explain quantum computing"
  ask -h "What is 2+2?"

  # Pipe input as prompt
  echo "Fix this code" | ask

  # Claude can run commands (recommended for git diffs)
  ask "Look at git diff and write a commit message"
  ask "Run git status and summarize changes"

  # File editing (enabled by default)
  ask "Read README.md and update it with current features"
  ask "Fix the bug in server.js"
  ask --no-edits "Just analyze server.js, don't modify it"

  # Pipe context with --context flag (alternative)
  git diff | ask --context "Write a commit message for this diff"
  cat error.log | ask --context "Explain what caused this error"

  # Show stats to see tool usage and cost
  ask --stats "Run git status and summarize changes"
  # Output: [sonnet - 8.23s - 1 tool calls - 142 tokens - \$0.0145]

  # Other options
  ask --system "You are a pirate" "Tell me about sailing"
  ask -r "Tell me a joke"
  ask --debug "Show me debug output"

EOF
    exit 0
}

# Gather system information
gather_sysinfo() {
    # OS and Distribution
    local os_info=$(grep -E '^(NAME|VERSION_ID)=' /etc/os-release 2>/dev/null | \
                    cut -d= -f2 | tr -d '"' | paste -sd ' ' 2>/dev/null || \
                    echo "$(uname -s) $(uname -r)")

    # Architecture
    local arch=$(uname -m)

    # Package Manager
    local pkg_mgr="unknown"
    for pm in apt dnf yum pacman nix brew; do
        if command -v "$pm" >/dev/null 2>&1; then
            pkg_mgr="$pm"
            break
        fi
    done

    # Shell
    local shell_name=$(basename "$SHELL" 2>/dev/null || echo "bash")

    # Development Tools
    local tools=""
    for tool in python3 node npm docker git make gcc nix pip cargo go java rustc; do
        command -v "$tool" >/dev/null 2>&1 && tools="${tools}${tool},"
    done
    tools=${tools%,}  # Remove trailing comma

    # Working Directory
    local wd=$(pwd)

    # Git Repository
    local in_git="no"
    git rev-parse --is-inside-work-tree >/dev/null 2>&1 && in_git="yes"

    # Project Type
    local proj_type="none"
    if [ -f package.json ]; then proj_type="node"
    elif [ -f requirements.txt ] || [ -f pyproject.toml ]; then proj_type="python"
    elif [ -f Cargo.toml ]; then proj_type="rust"
    elif [ -f go.mod ]; then proj_type="go"
    elif [ -f pom.xml ] || [ -f build.gradle ]; then proj_type="java"
    elif [ -f Makefile ]; then proj_type="make"
    fi

    # Format output (one line per item for easy parsing)
    cat << EOF
OS=$os_info
ARCH=$arch
PKG=$pkg_mgr
SHELL=$shell_name
TOOLS=$tools
WD=$wd
GIT=$in_git
PROJECT=$proj_type
EOF
}

# Check if cache should be refreshed
should_refresh_cache() {
    [ ! -f "$CACHE_FILE" ] && return 0

    # Try to get file modification time
    local cache_mtime
    if cache_mtime=$(stat -c %Y "$CACHE_FILE" 2>/dev/null); then
        : # GNU stat worked
    elif cache_mtime=$(stat -f %m "$CACHE_FILE" 2>/dev/null); then
        : # BSD stat worked
    else
        return 0  # Can't determine age, refresh
    fi

    local now=$(date +%s)
    local age=$((now - cache_mtime))

    [ "$age" -gt "$CACHE_MAX_AGE" ] && return 0
    return 1
}

# Get system context (cached)
get_system_context() {
    # Create cache directory if needed
    if [ ! -d "$CACHE_DIR" ]; then
        mkdir -p "$CACHE_DIR" 2>/dev/null || {
            # Fallback to temp
            CACHE_DIR="/tmp/ask-${USER:-default}"
            CACHE_FILE="$CACHE_DIR/sysinfo"
            mkdir -p "$CACHE_DIR" 2>/dev/null || return 1
        }
    fi

    # Refresh cache if needed
    if should_refresh_cache; then
        gather_sysinfo > "$CACHE_FILE" 2>/dev/null || return 1
    fi

    # Read and format cache
    if [ -f "$CACHE_FILE" ]; then
        # Parse cache file
        local os_info arch pkg_mgr shell_name tools wd in_git proj_type

        while IFS='=' read -r key value; do
            case "$key" in
                OS) os_info="$value" ;;
                ARCH) arch="$value" ;;
                PKG) pkg_mgr="$value" ;;
                SHELL) shell_name="$value" ;;
                TOOLS) tools="$value" ;;
                WD) wd="$value" ;;
                GIT) in_git="$value" ;;
                PROJECT) proj_type="$value" ;;
            esac
        done < "$CACHE_FILE"

        # Format concise context
        local context="System: $os_info $arch | Shell: $shell_name | Pkg: $pkg_mgr"
        [ -n "$tools" ] && context="$context
Tools: $tools"

        local ctx_detail="Context: $wd"
        [ "$in_git" = "yes" ] && ctx_detail="$ctx_detail | Git repo"
        [ "$proj_type" != "none" ] && ctx_detail="$ctx_detail | ${proj_type} project"
        context="$context
$ctx_detail"

        echo "$context"
    fi
}

# Parse command line arguments
while [ $# -gt 0 ]; do
    case "$1" in
        --help) show_help ;;
        --debug)
            DEBUG=true
            shift ;;
        --stats)
            SHOW_STATS=true
            shift ;;
        --context)
            WITH_CONTEXT=true
            shift ;;
        --allow-edits)
            ALLOW_EDITS=true
            shift ;;
        --no-edits)
            ALLOW_EDITS=false
            shift ;;
        --permission-mode)
            PERMISSION_MODE="${2:?Error: --permission-mode requires a value}"
            shift 2 ;;
        --allowed-tools)
            ALLOWED_TOOLS="${2:?Error: --allowed-tools requires a value}"
            shift 2 ;;
        -[soh])
            MODEL="$(get_model "${1:1}")"
            shift ;;
        -m)
            MODEL="${2:?Error: -m requires a model name}"
            shift 2 ;;
        -r)
            NO_SYSTEM=true
            shift ;;
        --system)
            SYSTEM_PROMPT="${2:?Error: --system requires a prompt}"
            shift 2 ;;
        *)
            PROMPT="$*"
            break ;;
    esac
done

# Handle stdin and prompt
if [ "$WITH_CONTEXT" = true ]; then
    # --context mode: read stdin as context, combine with prompt
    if [ ! -t 0 ]; then
        STDIN_CONTENT=$(cat)
        if [ -z "$PROMPT" ]; then
            echo "Error: --context requires both stdin and a prompt argument" >&2
            exit 1
        fi
        # Combine stdin content with prompt
        PROMPT="${STDIN_CONTENT}

---

${PROMPT}"
    else
        echo "Error: --context requires stdin input. Use: command | ask --context \"prompt\"" >&2
        exit 1
    fi
elif [ -z "$PROMPT" ]; then
    # No prompt argument: read from stdin
    if [ -t 0 ]; then
        echo "Error: No prompt provided. Use 'ask --help' for help." >&2
        exit 1
    fi
    # Read all stdin, preserving multi-line format
    PROMPT=$(cat)
else
    # Prompt provided: warn if stdin is being ignored
    if [ ! -t 0 ]; then
        echo "Warning: stdin detected but will be ignored. Use --context to include it." >&2
        # Consume stdin to prevent it from being passed to claude
        cat > /dev/null
    fi
fi

# Gather system context (unless in raw mode)
SYSTEM_CONTEXT=""
if [ "$NO_SYSTEM" = false ]; then
    SYSTEM_CONTEXT=$(get_system_context)
fi

# Apply default system prompt unless disabled or custom prompt provided
if [ "$NO_SYSTEM" = false ] && [ -z "$SYSTEM_PROMPT" ]; then
    SYSTEM_PROMPT="$DEFAULT_PROMPT"
fi

# Prepend system context to system prompt
if [ -n "$SYSTEM_CONTEXT" ] && [ -n "$SYSTEM_PROMPT" ]; then
    SYSTEM_PROMPT="${SYSTEM_CONTEXT}

${SYSTEM_PROMPT}"
fi

# Record start time
START_TIME=$(date +%s.%N)

# Build Claude CLI command with optional flags
CLAUDE_ARGS="-p \"$PROMPT\" --model \"$MODEL\""

# Add system prompt if provided
[ -n "$SYSTEM_PROMPT" ] && CLAUDE_ARGS="$CLAUDE_ARGS --system-prompt \"$SYSTEM_PROMPT\""

# Add permission flags
if [ "$ALLOW_EDITS" = true ]; then
    CLAUDE_ARGS="$CLAUDE_ARGS --permission-mode acceptEdits"
fi

[ -n "$PERMISSION_MODE" ] && CLAUDE_ARGS="$CLAUDE_ARGS --permission-mode \"$PERMISSION_MODE\""
[ -n "$ALLOWED_TOOLS" ] && CLAUDE_ARGS="$CLAUDE_ARGS --allowedTools \"$ALLOWED_TOOLS\""

# Always request JSON output
CLAUDE_ARGS="$CLAUDE_ARGS --output-format json"

# Debug output
if [ "$DEBUG" = true ]; then
    echo "=== SYSTEM CONTEXT ===" >&2
    if [ -n "$SYSTEM_CONTEXT" ]; then
        echo "$SYSTEM_CONTEXT" >&2
    else
        echo "(none)" >&2
    fi
    echo >&2

    echo "=== SYSTEM PROMPT ===" >&2
    if [ -n "$SYSTEM_PROMPT" ]; then
        echo "$SYSTEM_PROMPT" >&2
    else
        echo "(none)" >&2
    fi
    echo >&2

    echo "=== USER PROMPT ===" >&2
    echo "$PROMPT" >&2
    echo >&2

    echo "=== CLAUDE COMMAND ===" >&2
    echo "claude $CLAUDE_ARGS" | sed 's/"[^"]*"/"<...>"/g' >&2
    echo >&2
fi

# Add newline before answer
echo

# Execute Claude CLI
response=$(eval claude $CLAUDE_ARGS 2>&1)
exit_code=$?

# Debug output for response
if [ "$DEBUG" = true ]; then
    echo "=== RAW RESPONSE ===" >&2
    echo "$response" >&2
    echo >&2
fi

# Check for errors
if [ $exit_code -ne 0 ]; then
    echo "Error: Claude CLI failed" >&2
    echo "$response" >&2
    exit 1
fi

# Extract and print content from JSON response
content=$(echo "$response" | jq -r '.result // empty' 2>/dev/null)

# Check if result is empty or if there were permission denials
if [ -z "$content" ]; then
    # Check for permission denials
    denials=$(echo "$response" | jq -r '.permission_denials // [] | length' 2>/dev/null)
    if [ "$denials" != "0" ] && [ "$denials" != "null" ]; then
        echo "Error: Claude tried to perform an action but was denied permission." >&2
        echo "" >&2
        echo "Denied actions:" >&2
        echo "$response" | jq -r '.permission_denials[] | "  - \(.tool_name)"' 2>/dev/null >&2
        echo "" >&2
        echo "This may happen if:" >&2
        echo "  1. File is outside current working directory" >&2
        echo "  2. Insufficient file system permissions" >&2
        echo "  3. Run: claude (interactive mode) for more control" >&2
        exit 1
    else
        # No content and no denials - unexpected
        echo "Error: No response content received" >&2
        [ "$DEBUG" = true ] && echo "$response" >&2
        exit 1
    fi
fi

echo "$content"

# Show metadata (only if --stats enabled)
if [ "$SHOW_STATS" = true ]; then
    # ANSI color codes
    GRAY='\033[90m'
    BLUE='\033[94m'
    GREEN='\033[92m'
    YELLOW='\033[93m'
    RESET='\033[0m'

    ELAPSED=$(printf "%.2f" $(echo "$(date +%s.%N) - $START_TIME" | bc))
    INPUT_TOKENS=$(echo "$response" | jq -r '.usage.input_tokens // .input_tokens // 0' 2>/dev/null)
    OUTPUT_TOKENS=$(echo "$response" | jq -r '.usage.output_tokens // .output_tokens // 0' 2>/dev/null)
    NUM_TURNS=$(echo "$response" | jq -r '.num_turns // 0' 2>/dev/null)
    COST=$(echo "$response" | jq -r '.total_cost_usd // 0' 2>/dev/null)

    echo >&2
    # Build metadata string with colors
    metadata="${GRAY}[${BLUE}${MODEL}${GRAY} - ${GREEN}${ELAPSED}s${RESET}"

    # Calculate tool calls (turns - 1)
    if [ "$NUM_TURNS" != "0" ] && [ "$NUM_TURNS" != "null" ]; then
        TOOL_CALLS=$((NUM_TURNS - 1))
        metadata="$metadata${GRAY} - ${YELLOW}${TOOL_CALLS} tool calls${RESET}"
    fi

    # Add tokens and cost/tps if available
    if [ "$OUTPUT_TOKENS" != "0" ] && [ "$OUTPUT_TOKENS" != "null" ]; then
        metadata="$metadata${GRAY} - ${RESET}${OUTPUT_TOKENS} tokens"

        # Show cost if available (rounded to 4 decimal places), otherwise show tok/s
        if [ "$COST" != "0" ] && [ "$COST" != "null" ]; then
            ROUNDED_COST=$(printf "%.4f" "$COST")
            metadata="$metadata${GRAY} - ${GREEN}\$${ROUNDED_COST}${RESET}"
        else
            TPS=$(echo "scale=1; $OUTPUT_TOKENS / $ELAPSED" | bc 2>/dev/null || echo "0.0")
            metadata="$metadata${GRAY} - ${GREEN}${TPS} tok/s${RESET}"
        fi
    fi

    echo -e "$metadata${GRAY}]${RESET}" >&2
fi
