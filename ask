#!/usr/bin/env bash

# ask - Simple Claude Code CLI wrapper
# Usage: ask [OPTIONS] [PROMPT]

set -euo pipefail

# Check for Claude CLI
if ! command -v claude &> /dev/null; then
    echo "Error: claude command not found. Install Claude Code CLI first." >&2
    echo "Visit: https://claude.com/claude-code" >&2
    exit 1
fi

# Model shortcuts function
get_model() {
    case "$1" in
        s) echo "sonnet" ;;
        o) echo "opus" ;;
        h) echo "haiku" ;;
    esac
}

# System information caching
CACHE_DIR="${XDG_CACHE_HOME:-$HOME/.cache}/ask"
CACHE_FILE="$CACHE_DIR/sysinfo"
CACHE_MAX_AGE=86400  # 24 hours in seconds

# Default values
MODEL="sonnet"
SYSTEM_PROMPT=""
PROMPT=""
NO_SYSTEM=false
DEBUG=false
WITH_CONTEXT=false

# Default system prompt (direct answers)
DEFAULT_PROMPT="You are a direct answer engine. Output ONLY the requested information.

For commands: Output executable syntax only. No explanations, no comments.
For questions: Output the answer only. No context, no elaboration.

Rules:
- If asked for a command, provide ONLY the command
- If asked a question, provide ONLY the answer
- Never include markdown formatting or code blocks
- Never add explanatory text before or after
- Assume output will be piped or executed directly
- For multi-step commands, use && or ; to chain them
- Make commands robust and handle edge cases silently"

# Function to show help
show_help() {
    cat << EOF
ask - Query Claude AI via Claude Code CLI

Usage: ask [OPTIONS] [PROMPT]

Options:
  -s          Use Claude Sonnet (default)
  -o          Use Claude Opus
  -h          Use Claude Haiku
  -m MODEL    Use custom Claude model
  -r          Disable system prompt (raw model behavior)
  --system    Set custom system prompt for the conversation
  --context   Pipe stdin as context, combine with prompt argument
  --debug     Show system context, prompts, and command (output to stderr)
  --help      Show this help message

Examples:
  # Basic usage
  ask "Write a hello world in Python"
  ask -o "Explain quantum computing"
  ask -h "What is 2+2?"

  # Pipe input as prompt
  echo "Fix this code" | ask

  # Claude can run commands (recommended for git diffs)
  ask "Look at git diff and write a commit message"
  ask "Run git status and summarize changes"

  # Pipe context with --context flag (alternative)
  git diff | ask --context "Write a commit message for this diff"
  cat error.log | ask --context "Explain what caused this error"

  # Other options
  ask --system "You are a pirate" "Tell me about sailing"
  ask -r "Tell me a joke"
  ask --debug "Show me debug output"

EOF
    exit 0
}

# Gather system information
gather_sysinfo() {
    # OS and Distribution
    local os_info=$(grep -E '^(NAME|VERSION_ID)=' /etc/os-release 2>/dev/null | \
                    cut -d= -f2 | tr -d '"' | paste -sd ' ' 2>/dev/null || \
                    echo "$(uname -s) $(uname -r)")

    # Architecture
    local arch=$(uname -m)

    # Package Manager
    local pkg_mgr="unknown"
    for pm in apt dnf yum pacman nix brew; do
        if command -v "$pm" >/dev/null 2>&1; then
            pkg_mgr="$pm"
            break
        fi
    done

    # Shell
    local shell_name=$(basename "$SHELL" 2>/dev/null || echo "bash")

    # Development Tools
    local tools=""
    for tool in python3 node npm docker git make gcc nix pip cargo go java rustc; do
        command -v "$tool" >/dev/null 2>&1 && tools="${tools}${tool},"
    done
    tools=${tools%,}  # Remove trailing comma

    # Working Directory
    local wd=$(pwd)

    # Git Repository
    local in_git="no"
    git rev-parse --is-inside-work-tree >/dev/null 2>&1 && in_git="yes"

    # Project Type
    local proj_type="none"
    if [ -f package.json ]; then proj_type="node"
    elif [ -f requirements.txt ] || [ -f pyproject.toml ]; then proj_type="python"
    elif [ -f Cargo.toml ]; then proj_type="rust"
    elif [ -f go.mod ]; then proj_type="go"
    elif [ -f pom.xml ] || [ -f build.gradle ]; then proj_type="java"
    elif [ -f Makefile ]; then proj_type="make"
    fi

    # Format output (one line per item for easy parsing)
    cat << EOF
OS=$os_info
ARCH=$arch
PKG=$pkg_mgr
SHELL=$shell_name
TOOLS=$tools
WD=$wd
GIT=$in_git
PROJECT=$proj_type
EOF
}

# Check if cache should be refreshed
should_refresh_cache() {
    [ ! -f "$CACHE_FILE" ] && return 0

    # Try to get file modification time
    local cache_mtime
    if cache_mtime=$(stat -c %Y "$CACHE_FILE" 2>/dev/null); then
        : # GNU stat worked
    elif cache_mtime=$(stat -f %m "$CACHE_FILE" 2>/dev/null); then
        : # BSD stat worked
    else
        return 0  # Can't determine age, refresh
    fi

    local now=$(date +%s)
    local age=$((now - cache_mtime))

    [ "$age" -gt "$CACHE_MAX_AGE" ] && return 0
    return 1
}

# Get system context (cached)
get_system_context() {
    # Create cache directory if needed
    if [ ! -d "$CACHE_DIR" ]; then
        mkdir -p "$CACHE_DIR" 2>/dev/null || {
            # Fallback to temp
            CACHE_DIR="/tmp/ask-${USER:-default}"
            CACHE_FILE="$CACHE_DIR/sysinfo"
            mkdir -p "$CACHE_DIR" 2>/dev/null || return 1
        }
    fi

    # Refresh cache if needed
    if should_refresh_cache; then
        gather_sysinfo > "$CACHE_FILE" 2>/dev/null || return 1
    fi

    # Read and format cache
    if [ -f "$CACHE_FILE" ]; then
        # Parse cache file
        local os_info arch pkg_mgr shell_name tools wd in_git proj_type

        while IFS='=' read -r key value; do
            case "$key" in
                OS) os_info="$value" ;;
                ARCH) arch="$value" ;;
                PKG) pkg_mgr="$value" ;;
                SHELL) shell_name="$value" ;;
                TOOLS) tools="$value" ;;
                WD) wd="$value" ;;
                GIT) in_git="$value" ;;
                PROJECT) proj_type="$value" ;;
            esac
        done < "$CACHE_FILE"

        # Format concise context
        local context="System: $os_info $arch | Shell: $shell_name | Pkg: $pkg_mgr"
        [ -n "$tools" ] && context="$context
Tools: $tools"

        local ctx_detail="Context: $wd"
        [ "$in_git" = "yes" ] && ctx_detail="$ctx_detail | Git repo"
        [ "$proj_type" != "none" ] && ctx_detail="$ctx_detail | ${proj_type} project"
        context="$context
$ctx_detail"

        echo "$context"
    fi
}

# Parse command line arguments
while [ $# -gt 0 ]; do
    case "$1" in
        --help) show_help ;;
        --debug)
            DEBUG=true
            shift ;;
        --context)
            WITH_CONTEXT=true
            shift ;;
        -[soh])
            MODEL="$(get_model "${1:1}")"
            shift ;;
        -m)
            MODEL="${2:?Error: -m requires a model name}"
            shift 2 ;;
        -r)
            NO_SYSTEM=true
            shift ;;
        --system)
            SYSTEM_PROMPT="${2:?Error: --system requires a prompt}"
            shift 2 ;;
        *)
            PROMPT="$*"
            break ;;
    esac
done

# Handle stdin and prompt
if [ "$WITH_CONTEXT" = true ]; then
    # --context mode: read stdin as context, combine with prompt
    if [ ! -t 0 ]; then
        STDIN_CONTENT=$(cat)
        if [ -z "$PROMPT" ]; then
            echo "Error: --context requires both stdin and a prompt argument" >&2
            exit 1
        fi
        # Combine stdin content with prompt
        PROMPT="${STDIN_CONTENT}

---

${PROMPT}"
    else
        echo "Error: --context requires stdin input. Use: command | ask --context \"prompt\"" >&2
        exit 1
    fi
elif [ -z "$PROMPT" ]; then
    # No prompt argument: read from stdin
    if [ -t 0 ]; then
        echo "Error: No prompt provided. Use 'ask --help' for help." >&2
        exit 1
    fi
    # Read all stdin, preserving multi-line format
    PROMPT=$(cat)
fi

# Gather system context (unless in raw mode)
SYSTEM_CONTEXT=""
if [ "$NO_SYSTEM" = false ]; then
    SYSTEM_CONTEXT=$(get_system_context)
fi

# Apply default system prompt unless disabled or custom prompt provided
if [ "$NO_SYSTEM" = false ] && [ -z "$SYSTEM_PROMPT" ]; then
    SYSTEM_PROMPT="$DEFAULT_PROMPT"
fi

# Prepend system context to system prompt
if [ -n "$SYSTEM_CONTEXT" ] && [ -n "$SYSTEM_PROMPT" ]; then
    SYSTEM_PROMPT="${SYSTEM_CONTEXT}

${SYSTEM_PROMPT}"
fi

# Record start time
START_TIME=$(date +%s.%N)

# Debug output
if [ "$DEBUG" = true ]; then
    echo "=== SYSTEM CONTEXT ===" >&2
    if [ -n "$SYSTEM_CONTEXT" ]; then
        echo "$SYSTEM_CONTEXT" >&2
    else
        echo "(none)" >&2
    fi
    echo >&2

    echo "=== SYSTEM PROMPT ===" >&2
    if [ -n "$SYSTEM_PROMPT" ]; then
        echo "$SYSTEM_PROMPT" >&2
    else
        echo "(none)" >&2
    fi
    echo >&2

    echo "=== USER PROMPT ===" >&2
    echo "$PROMPT" >&2
    echo >&2

    # Build debug command string
    debug_cmd="claude -p \"<PROMPT>\" --model \"$MODEL\""
    [ -n "$SYSTEM_PROMPT" ] && debug_cmd="$debug_cmd --system-prompt \"<SYSTEM_PROMPT>\""
    debug_cmd="$debug_cmd --output-format json"

    echo "=== CLAUDE COMMAND ===" >&2
    echo "$debug_cmd" >&2
    echo >&2
fi

# Add newline before answer
echo

# Execute Claude CLI with proper argument passing
if [ -n "$SYSTEM_PROMPT" ]; then
    # With custom system prompt
    response=$(claude -p "$PROMPT" --model "$MODEL" --system-prompt "$SYSTEM_PROMPT" --output-format json 2>&1)
else
    # Without system prompt (raw mode)
    response=$(claude -p "$PROMPT" --model "$MODEL" --output-format json 2>&1)
fi

exit_code=$?

# Debug output for response
if [ "$DEBUG" = true ]; then
    echo "=== RAW RESPONSE ===" >&2
    echo "$response" >&2
    echo >&2
fi

# Check for errors
if [ $exit_code -ne 0 ]; then
    echo "Error: Claude CLI failed" >&2
    echo "$response" >&2
    exit 1
fi

# Extract and print content from JSON response
content=$(echo "$response" | jq -r '.result // .content // .response // .' 2>/dev/null)

# If jq parsing failed or returned null, just print the raw response
if [ -z "$content" ] || [ "$content" = "null" ]; then
    echo "$response"
else
    echo "$content"
fi

# Show metadata
ELAPSED=$(printf "%.2f" $(echo "$(date +%s.%N) - $START_TIME" | bc))
INPUT_TOKENS=$(echo "$response" | jq -r '.input_tokens // 0' 2>/dev/null)
OUTPUT_TOKENS=$(echo "$response" | jq -r '.output_tokens // 0' 2>/dev/null)

echo
if [ "$INPUT_TOKENS" != "0" ] && [ "$OUTPUT_TOKENS" != "0" ]; then
    TPS=$(echo "scale=1; $OUTPUT_TOKENS / $ELAPSED" | bc 2>/dev/null || echo "0.0")
    echo "[$MODEL - ${ELAPSED}s - ${OUTPUT_TOKENS} tokens - ${TPS} tok/s]" >&2
else
    echo "[$MODEL - ${ELAPSED}s]" >&2
fi
